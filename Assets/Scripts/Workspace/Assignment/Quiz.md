# แบบทดสอบ Sequential Search และ Binary Search

## Quiz Item 2: ความซับซ้อนของเวลาใน Sequential Search
**คำถาม:** Sequential Search มีความซับซ้อนของเวลาในกรณีที่แย่ที่สุดสำหรับอาร์เรย์ที่มี n องค์ประกอบคืออะไร?  
A) O(1)  
B) O(log n)  
C) O(n)  
D) O(n log n)  

**คำตอบที่ถูกต้อง:** C) O(n)  
**หมายเหตุ:** ในกรณีที่แย่ที่สุด Sequential Search ต้องตรวจสอบทุกองค์ประกอบในอาร์เรย์ ทำให้มี O(n) ความซับซ้อนของเวลา

## Quiz Item 3: ข้อกำหนดสำหรับ Binary Search
**คำถาม:** อะไรคือเงื่อนไขที่จำเป็นสำหรับ Binary Search เพื่อทำงานได้อย่างถูกต้อง?  
A) อาร์เรย์ต้องว่างเปล่า  
B) อาร์เรย์ต้องเรียงลำดับ  
C) อาร์เรย์ต้องมีองค์ประกอบซ้ำ  
D) อาร์เรย์ต้องเรียงลำดับย้อนกลับ  

**คำตอบที่ถูกต้อง:** B) อาร์เรย์ต้องเรียงลำดับ  
**หมายเหตุ:** Binary Search ต้องการให้อาร์เรย์เรียงลำดับจากน้อยไปมากหรือมากไปน้อย เพื่อแบ่งพื้นที่ค้นหาได้อย่างมีประสิทธิภาพ

## Quiz Item 4: ความซับซ้อนของเวลาใน Binary Search
**คำถาม:** Binary Search มีความซับซ้อนของเวลาเท่าไร?  
A) O(1)  
B) O(n)  
C) O(log n)  
D) O(n^2)  

**คำตอบที่ถูกต้อง:** C) O(log n)  
**หมายเหตุ:** Binary Search แบ่งพื้นที่ค้นหาเป็นครึ่งหนึ่งในแต่ละครั้ง ทำให้มีความซับซ้อนของเวลาเป็น logarithmic

## Quiz Item 5: กรณีที่ดีที่สุดสำหรับ Sequential Search
**คำถาม:** ในสถานการณ์ใดที่ Sequential Search ดีกว่า Binary Search?  
A) ค้นหาในฐานข้อมูลขนาดใหญ่ที่เรียงลำดับแล้ว  
B) ค้นหาในรายการขนาดเล็กที่ไม่เรียงลำดับ  
C) ค้นหาในอาร์เรย์ที่เรียงลำดับแล้วที่มีล้านองค์ประกอบ  
D) ค้นหาใน binary tree  

**คำตอบที่ถูกต้อง:** B) ค้นหาในรายการขนาดเล็กที่ไม่เรียงลำดับ  
**หมายเหตุ:** Sequential Search เรียบง่ายและทำงานได้กับข้อมูลที่ไม่เรียงลำดับ ทำให้เหมาะสำหรับรายการขนาดเล็กที่ไม่คุ้มกับการเรียงลำดับ

## Quiz Item 6: การคำนวณจุดกึ่งกลางใน Binary Search
**คำถาม:** ใน Binary Search จุดกึ่งกลางของดัชนีมักคำนวณอย่างไร?  
A) (left + right) / 2  
B) left + (right - left) / 2  
C) (left * right) / 2  
D) right - left / 2  

**คำตอบที่ถูกต้อง:** B) left + (right - left) / 2  
**หมายเหตุ:** สูตรนี้หลีกเลี่ยงการ overflow ของจำนวนเต็มที่อาจเกิดขึ้นกับ (low + high) / 2 เมื่อ low และ high เป็นตัวเลขขนาดใหญ่

## Quiz Item 7: Sequential Search บนอาร์เรย์ที่เรียงลำดับ
**คำถาม:** ถ้าคุณมีอาร์เรย์ที่เรียงลำดับและต้องการหาว่าองค์ประกอบมีอยู่หรือไม่ การค้นหาแบบใดที่รับประกันได้ว่าจะทำงาน?  
A) เฉพาะ Binary Search  
B) เฉพาะ Sequential Search  
C) ทั้ง Binary Search และ Sequential Search  
D) ไม่มีเลย ต้องใช้อัลกอริทึมอื่น  

**คำตอบที่ถูกต้อง:** C) ทั้ง Binary Search และ Sequential Search  
**หมายเหตุ:** Sequential Search ทำงานได้กับอาร์เรย์ทุกประเภท ไม่ว่าจะเรียงลำดับหรือไม่ ในขณะที่ Binary Search ต้องการการเรียงลำดับ แต่ทั้งสองสามารถหาองค์ประกอบในอาร์เรย์ที่เรียงลำดับได้

## Quiz Item 8: กรณีที่ Binary Search ล้มเหลว
**คำถาม:** จะเกิดอะไรขึ้นถ้าคุณพยายามทำ Binary Search บนอาร์เรย์ที่ไม่เรียงลำดับ?  
A) มันจะหาองค์ประกอบที่ถูกต้องเสมอ  
B) มันอาจไม่หาองค์ประกอบได้แม้ว่าจะมีอยู่  
C) มันจะเรียงลำดับอาร์เรย์โดยอัตโนมัติ  
D) มันจะโยน exception  

**คำตอบที่ถูกต้อง:** B) มันอาจไม่หาองค์ประกอบได้แม้ว่าจะมีอยู่  
**หมายเหตุ:** Binary Search สมมติว่าอาร์เรย์เรียงลำดับแล้ว บนข้อมูลที่ไม่เรียงลำดับ มันอาจพลาดองค์ประกอบหรือส่งผลลัพธ์ที่ไม่ถูกต้อง

## Quiz Item 9: การเปรียบเทียบความซับซ้อนของพื้นที่
**คำถาม:** การค้นหาแบบใดที่มีความซับซ้อนของพื้นที่ที่ดีกว่าโดยทั่วไป?  
A) Sequential Search  
B) Binary Search  
C) ทั้งสองมีเหมือนกัน  
D) ขึ้นอยู่กับการ implement  

**คำตอบที่ถูกต้อง:** C) ทั้งสองมีเหมือนกัน  
**หมายเหตุ:** ทั้ง Sequential Search และ Binary Search โดยทั่วไปใช้ O(1) พื้นที่เพิ่มเติม ทำให้มีประสิทธิภาพเท่ากันในแง่ของพื้นที่

## Quiz Item 10: ข้อดีของ Sequential Search
**คำถาม:** ข้อดีที่สำคัญของ Sequential Search มากกว่า Binary Search คืออะไร?  
A) เร็วกว่าในชุดข้อมูลขนาดใหญ่  
B) ทำงานได้กับข้อมูลที่ไม่เรียงลำดับ  
C) ใช้หน่วยความจำน้อยกว่า  
D) ง่ายต่อการ implement แบบ recursive  

**คำตอบที่ถูกต้อง:** B) ทำงานได้กับข้อมูลที่ไม่เรียงลำดับ  
**หมายเหตุ:** Sequential Search ไม่ต้องการให้ข้อมูลเรียงลำดับ ทำให้มีความยืดหยุ่นมากขึ้นสำหรับการจัดเรียงข้อมูลต่างๆ

## Quiz Item 11: Binary Search แบบ Recursion
**คำถาม:** Binary Search สามารถ implement โดยใช้ paradigm ทาง programming แบบใด?  
A) เฉพาะ iterative  
B) เฉพาะ recursive  
C) ทั้ง iterative และ recursive  
D) ไม่มีเลย  

**คำตอบที่ถูกต้อง:** C) ทั้ง iterative และ recursive  
**หมายเหตุ:** Binary Search สามารถเขียนเป็น loop แบบ iterative หรือฟังก์ชันแบบ recursive ได้ โดยทั้งสองให้ประสิทธิภาพเท่ากัน

## Quiz Item 12: Sequential Search ใน Linked List
**คำถาม:** การค้นหาแบบใดที่เหมาะสมกว่าสำหรับโครงสร้างข้อมูล linked list?  
A) Binary Search  
B) Sequential Search  
C) ทั้งสองเหมาะสมเท่ากัน  
D) ไม่มีเลยที่เหมาะสม  

**คำตอบที่ถูกต้อง:** B) Sequential Search  
**หมายเหตุ:** Linked list ไม่รองรับการเข้าถึงแบบสุ่ม ดังนั้น Binary Search ซึ่งต้องการการกระโดดไปยังจุดกึ่งกลางจึงไม่มีประสิทธิภาพ Sequential Search จึงเป็นที่ต้องการ

## Quiz Item 13: ตัวอย่างโค้ด Sequential Search
**คำถาม:** ในโค้ดต่อไปนี้ Sequential Search หาค่า target ในอาร์เรย์ได้อย่างไร?  
```csharp
int[] array = new int[] { 34, 21, 56, 12, 78, 90, 11, 23 };
int target = 90;
int index = -1;

for (int i = 0; i < array.Length; i++)
{
    if (array[i] == target)
    {
        index = i;
        break;
    }
}
```  
A) โดยการเปรียบเทียบกับองค์ประกอบกึ่งกลาง  
B) โดยการตรวจสอบองค์ประกอบทีละตัวจากต้นจนจบ  
C) โดยการเรียงลำดับอาร์เรย์ก่อน  
D) โดยการเรียงลำดับอาร์เรย์ก่อน

**คำตอบที่ถูกต้อง:** B) โดยการตรวจสอบองค์ประกอบทีละตัวจากต้นจนจบ  
**หมายเหตุ:** Sequential Search วนลูปผ่านอาร์เรย์และตรวจสอบแต่ละองค์ประกอบจนกว่าจะพบ target หรือถึงจุดสิ้นสุด

## Quiz Item 14: ตัวอย่างโค้ด Binary Search
**คำถาม:** ในโค้ด Binary Search ต่อไปนี้ การคำนวณ mid ทำเพื่ออะไร?  
```csharp
int[] array = new int[] { 11, 12, 21, 23, 34, 45, 56, 78, 90 };
int target = 23;
int left = 0;
int right = array.Length - 1;
int index = -1;

while (left <= right)
{
    int mid = left + (right - left) / 2;

    if (array[mid] == target)
    {
        index = mid;
        break;
    }
    else if (array[mid] < target)
    {
        left = mid + 1;
    }
    else
    {
        right = mid - 1;
    }
}
```  
A) เพื่อหาดัชนีเริ่มต้น  
B) เพื่อหาจุดกึ่งกลางของช่วงค้นหาปัจจุบัน  
C) เพื่อนับจำนวนองค์ประกอบ  
D) เพื่อเรียงลำดับอาร์เรย์  

**คำตอบที่ถูกต้อง:** B) เพื่อหาจุดกึ่งกลางของช่วงค้นหาปัจจุบัน  
**หมายเหตุ:** ใน Binary Search mid ใช้เพื่อแบ่งช่วงค้นหาเป็นสองส่วนและตัดสินใจว่าจะค้นหาทางซ้ายหรือขวา
